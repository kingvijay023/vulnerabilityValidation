
<#
.SYNOPSIS
    This script is used to validate the recent Vulnerabilities.
	Spectre and Meltdown
.DESCRIPTION
    
.PARAMETER 
    NA
.INPUTS
    Use the Cofig_VulnerabilityValidation.ini to set the inputs
.OUTPUTS
    Output will be stored in the form of CSV
.NOTES
    Script:         WINDOWS-Bionics-IAF-VulnerabilityValidation.ps1 
    Author:         Vijayakumar Parameswaran
    Requirements:   Powershell v3.0
    Creation Date:  02-Mar-2018
    History:
        version 1.0.1 02-Mar-2018 - Initial script development
        version 1.0.2 XX-Mar-2018 - Added SMTP Mail feature
        version 1.0.3 20-Mar-2018 - Added separate columns for Spectre and Meltdown
        version 1.0.4 21-Mar-2018 - Added execution Policy settings
.EXAMPLE
    
#>

[CmdletBinding()]
[Alias()]
[OutputType([String])]
<#Param (
    # Change ticket or work request number for running the script
    [Parameter(
        HelpMessage = 'The change ticket or work request number',
        Mandatory = $false,
        ValueFromPipeline = $false)]
    [ValidateNotNullOrEmpty()]
    [ValidateLength(1,50)]
    [Alias("Ticket")]
    [string]$ChangeTicket,

    [Parameter(
        HelpMessage = 'To display the output only',
        Mandatory = $false)]
    [switch]$OutputOnly = $false,

    # Param1 help description
    [Parameter(Mandatory=$true,
        Position=0,
        ValueFromPipeline=$true,
        ValueFromPipelineByPropertyName=$true,
        ValueFromRemainingArguments=$false,
        ParameterSetName='Parameter Set 1')]
    [ValidateNotNull()]
    [ValidateNotNullOrEmpty()]
    [ValidateCount(0,5)]
    [ValidateSet("sun", "moon", "earth")]
    [Alias("p1")]
    $Param1,

    # Param2 help description
    [Parameter(ParameterSetName='Parameter Set 2')]
    [AllowNull()]
    [AllowEmptyCollection()]
    [AllowEmptyString()]
    [ValidateScript({$true})]
    [ValidateRange(0,5)]
    [int]
    $Param2,

    # Param3 help description
    [Parameter(ParameterSetName='Another Parameter Set')]
    [ValidatePattern("[a-z]*")]
    [ValidateLength(0,15)]
    [String]
    $Param3
)#>

#---------------------------------------------------------[Initializations]--------------------------------------------------------

#Set Error Action to Silently Continue
$ErrorActionPreference = "SilentlyContinue"
$DirectoryToSaveTo = Convert-Path .
$curdir = Convert-Path .
$date=Get-Date -format "yyyy-MM-d" 
$OutputOnly = $true
$comments = ""
$formattedResults = @()
$serverCount = 1
$serverNickName=" "
$Status=" "
$isHyperV=" "
$OSRunning=" "
$systemType=" "
$uptime=" "
$kb=" "
$patchStatus=" "
$isFirmwareUpdated=" "
$SPECTREmitigated=" "
$MeltDownmitigated=" "
$comments=" "

# List of modules to be loaded (Please remove modules not required for the script)
$moduleList = @()

#----------------------------------------------------------[Declarations]----------------------------------------------------------

#Script Version
$sScriptVersion = "1.0.3"
$Reportdate = get-date -format yyyyMMdd
$ScriptDesc = "VulnerabilityValidation" #Mention script description in short like MigrateFileShare or Migrate_File_Share
$logdir = $curdir
$logfile = $logdir + "\WINDOWS-Bionics_${ScriptDesc}_${Reportdate}.log"
$execDir = Get-Location

#-----------------------------------------------------------[Functions]------------------------------------------------------------

function Write-Log {
    Param
    (
        [String]$Text,
        [Int]$Flag
    )

    $Date = Get-Date -Format yyyy-MM-dd-HH:mm:ss

    If ($OutputOnly -eq $false) {
        Switch($Flag)
        {
            0 { Write-Output "$Date INFO: $Text" | Tee-Object -FilePath $LogFile -Append }
            1 { 
                $DefaultColor = $host.UI.RawUI.ForegroundColor
                $host.UI.RawUI.ForegroundColor = "Yellow"
                Write-Output "$Date WARN: $Text" | Tee-Object -FilePath $LogFile -Append
                $host.UI.RawUI.ForegroundColor = $DefaultColor
            }
            2 {
                $DefaultColor = $host.UI.RawUI.ForegroundColor
                $host.UI.RawUI.ForegroundColor = "Red"
                Write-Output "$Date ERRO: $Text" | Tee-Object -FilePath $LogFile -Append
                $host.UI.RawUI.ForegroundColor = $DefaultColor
             }
            3 { Write-Output "$Date DEBU: $Text" | Tee-Object -FilePath $LogFile -Append }
        }
    }
    else {
        Switch($Flag)
        {
            0 { Write-Output "$Date INFO: $Text" | Out-File $LogFile -append }
            1 { Write-Output "$Date WARN: $Text" | Out-File $LogFile -append }
            2 { Write-Output "$Date ERRO: $Text" | Out-File $LogFile -append }
            3 { Write-Output "$Date DEBU: $Text" | Out-File $LogFile -append }
        }
    }
}

function LoadModules(){
    if($moduleList -gt 0){
        Write-Log "Searching for module components..." 0
        $loaded = Get-Module -Name $moduleList -ErrorAction Ignore | ForEach-Object {$_.Name}
        $registered = Get-Module -Name $moduleList -ListAvailable -ErrorAction Ignore | ForEach-Object {$_.Name}
        
        foreach ($module in $registered) {
            if ($loaded -notcontains $module) {
                Write-Log "Loading module $module" 0
                Try {
                    Import-Module $module
                }
                Catch {
                    Write-Log "Error in importing module $module - $_.Exception.Message"
                    Exit 1
                }
            }
        }
   }
   else {
	    Write-Log "No modules to load. Proceeding to main script execution" 0
    }
}

Function Get-IniContent {  
    [CmdletBinding()]  
    Param(  
        [ValidateNotNullOrEmpty()]  
        [ValidateScript({(Test-Path $_) -and ((Get-Item $_).Extension -eq ".ini")})]  
        [Parameter(ValueFromPipeline=$True,Mandatory=$True)]  
        [string]$FilePath  
    )  
      
    Begin  
        {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function started"}  
          
    Process  
    {  
        Write-Verbose "$($MyInvocation.MyCommand.Name):: Processing file: $Filepath"  
              
        $ini = @{}  
        switch -regex -file $FilePath  
        {  
            "^\[(.+)\]$" # Section  
            {  
                $section = $matches[1]  
                $ini[$section] = @{}  
                $CommentCount = 0  
            }  
            "^(;.*)$" # Comment  
            {  
                if (!($section))  
                {  
                    $section = "No-Section"  
                    $ini[$section] = @{}  
                }  
                $value = $matches[1]  
                $CommentCount = $CommentCount + 1  
                $name = "Comment" + $CommentCount  
                $ini[$section][$name] = $value  
            }   
            "(.+?)\s*=\s*(.*)" # Key  
            {  
                if (!($section))  
                {  
                    $section = "No-Section"  
                    $ini[$section] = @{}  
                }  
                $name,$value = $matches[1..2]  
                $ini[$section][$name] = $value  
            }  
        }  
        Write-Verbose "$($MyInvocation.MyCommand.Name):: Finished Processing file: $FilePath"  
        Return $ini  
    }  
          
    End  
        {Write-Verbose "$($MyInvocation.MyCommand.Name):: Function ended"}  
}

Function Mailer ($emailTo) 
<# This is a simple function that that sends a message. 
The variables defined below can be passed as parameters by taking them out  
and putting then in the parentheseis above. 
 
i.e. "Function Mailer ($subject)" 
 
#> 
 
{ 
   $message = @" 
   Spectre & Meltdown Vulnerability Validation Script.
   Attached the Reports excel. For more debug information, please refer - $LogFile from the jumpserver, where the script was executed.
"@
Try
{
$smtp=New-Object Net.Mail.SmtpClient($smtpServer) 
$msg = new-object Net.Mail.MailMessage
$att = New-Object Net.Mail.Attachment($attPath)
$smtp.Timeout = 10000
$msg.Attachments.add($att)
$msg.From = $emailFrom
$msg.To.Add($emailTo)
$msg.Bcc.Add("Vijayakumar.parameswaran@hpe.com")
$msg.Subject =  $subject
$msg.Body =  $message
$mailResult = $smtp.Send($msg)
write-host $mailResult
$att.Dispose()

}
catch
{
 Write-Log "Some error occurred while sending Mail" 1
 Write-Log "Error $_.Exception.Message" 1
}
#$smtp=new-object Net.Mail.SmtpClient($smtpServer) 
#$smtp.Send($emailFrom, $emailTo, $subject, $message, $attPath) 
}

Function GetStatusCode 
{  
    Param([int] $StatusCode)   
    switch($StatusCode) 
    { 
        0         {"Available Online"} 
        11001   {"Buffer Too Small"} 
        11002   {"Destination Net Unreachable"} 
        11003   {"Destination Host Unreachable"} 
        11004   {"Destination Protocol Unreachable"} 
        11005   {"Destination Port Unreachable"} 
        11006   {"No Resources"} 
        11007   {"Bad Option"} 
        11008   {"Hardware Error"} 
        11009   {"Packet Too Big"} 
        11010   {"Request Timed Out"} 
        11011   {"Bad Request"} 
        11012   {"Bad Route"} 
        11013   {"TimeToLive Expired Transit"} 
        11014   {"TimeToLive Expired Reassembly"} 
        11015   {"Parameter Problem"} 
        11016   {"Source Quench"} 
        11017   {"Option Too Big"} 
        11018   {"Bad Destination"} 
        11032   {"Negotiating IPSEC"} 
        11050   {"General Failure"} 
        default {"Failed"} 
    }
	Write-Log "PCNotFound $server - $StatusCode. Error: $err", 2 	
}  

function UnLoadModules(){
    if($moduleList -gt 0){
        Write-Log "Searching for imported module components..." 0
   
        $loaded = Get-Module -Name $moduleList -ErrorAction Ignore | ForEach-Object {$_.Name}
        $registered = Get-Module -Name $moduleList -ListAvailable -ErrorAction Ignore | ForEach-Object {$_.Name}

        foreach ($module in $registered) {
            if ($loaded -contains $module) {
                Write-Log "Removing module $module" 0
                Try {
                    Remove-Module $module
                }
                Catch {
                    Write-Log "Error in Removing module $module - $_.Exception.Message"
                }		 
            }
        }
    }
   else {
	    Write-Log "No modules to load. Proceeding to main script execution" 0
    }
}


#-----------------------------------------------------------[Execution]------------------------------------------------------------
if(!(Test-Path -Path $logdir)){
    Try {
        Write-Host "Execution Begins"
        New-Item -ItemType directory -Force -Path $logdir
        Write-Log "Log directory $logdir didn't exist so had to create it" 1
    }
    Catch {
        Write-Host "Failed to create log directory $logdir"
        Write-Host "Completed Script with Errors"
        Write-Host " "
        Exit 1
    }
} else {
    Write-Log "Log directory $logdir exists " 0
}

Write-Log "Script Version - $sScriptVersion" 0
Write-Log "Beginning Script Execution" 0
Write-Log "Importing default Module" 0
Import-Module ".\SpeculationControl.psd1" -ErrorAction SilentlyContinue -ErrorVariable ModuleErr
if ($ModuleErr.count -eq 0)
{ Write-Log "Default Module Speculation Control has been loaded." 0 }
else
{Write-Log "Unable to load default Module. Execution will terminate." 2
 Return;}

LoadModules

#$iniContent = Get-IniContent ("$curdir\Vulnerability_Validation_Config.ini")
$iniContent = Get-IniContent "$curdir\Vulnerability_Validation_Config.ini"
$patchinfo = $iniContent["Patch"]["PatchToCheck"]
$ServerPrefix = $iniContent["Reporting"]["ServerPrefix"]
$Secure_Mode = $iniContent["Reporting"]["Secure_Mode"]
$smtpServer = $iniContent["SMTP"]["SMTP_Mail_Server"]
$emailFrom = $iniContent["SMTP"]["From_Address"]
$emailTo = $iniContent["SMTP"]["ToAddress"]
$subject = $iniContent["SMTP"]["MailSubject"]



$computers = If(Test-Path ($iniContent["Server List"]["Server_List"])) {Get-Content $iniContent["Server List"]["Server_List"]} else {Write-Host "Target Servers File Not Found." 2; Return;}


Try {
		$scriptstring = Get-Content -Path (Get-Module SpeculationControl).Path | % { if (-not ($_ -match “^\# “)) { $_ } } | Out-String

		$scriptstring += '

		function Write-Host {}

		'

		$scriptstring += 'Get-SpeculationControlSettings'

		$script=[scriptblock]::create($scriptstring) 
		
		foreach ($Computer in $Computers)
		{
         
         if (($Secure_Mode -eq "On" ) -Or ($Secure_Mode -eq "ON") -Or ($Secure_Mode -eq "on"))
         {
		 $serverNickName = $ServerPrefix + "00" + $serverCount
         }
         else { $serverNickName = $Computer}

		 $pingStatus = Get-WmiObject -Query "Select * from win32_PingStatus where Address='$Computer'" 
         Write-Log "Trying to connect to Server $computer" 0
         
		 if($pingStatus.StatusCode -eq 0) 
			{ 
                try
                {
      
                $vmms = Get-Service -Name vmms -ComputerName $Computer -ErrorAction SilentlyContinue
                if ($vmms.Status -eq 'Running') {
                    $isHyperV = $true
                }
                else {
                    $isHyperV = $false
                }
				$Status = GetStatusCode( $pingStatus.StatusCode ) 
				$OS = Get-WmiObject -Class Win32_OperatingSystem -ComputerName $Computer -ErrorVariable Err #-Credential $mycred 
				$sheetPU = Get-WmiObject -Class Win32_Processor -ComputerName $Computer -ErrorVariable Err #-Credential $mycred
				$OSRunning = $OS.caption + " " + $OS.OSArchitecture + " SP " + $OS.ServicePackMajorVersion 
				
                if ($sheetPU.Name -eq "")
                {$systemType = $sheetPU[0].Name}
                elseif ($sheetPU.Count -gt 1) 
                {$systemType = $sheetPU[0].Name}
                else {$systemType = $sheetPU.Name} 
                
				$date = Get-Date 
				$uptime = $OS.ConvertToDateTime($OS.lastbootuptime) 
				$kb=get-hotfix -ComputerName $computer -id $patchinfo -ErrorVariable Err #-Credential $mycred
                $Err.Clear()
                if ($computer -eq "localhost")
                {$execPolicy = Get-ExecutionPolicy -ErrorAction SilentlyContinue -ErrorVariable Err}
                else {
                    $execPolicy = Invoke-Command -ComputerName $computer -ScriptBlock {Get-ExecutionPolicy} -ErrorAction SilentlyContinue -ErrorVariable Err
                    }
                
                if ($Err.Count -eq 1)
                {
                    $patchStatus = "NA"                    
                    $SPECTREmitigated= "NA"
                    $MeltDownmitigated = "NA"
                    $isFirmWareUpdated = "NA"
                    $comments = "Remote command execution is not allowed. "
                    Write-Log "Error Connecting to targethost" 2
                }
                
                else {
				$results = Invoke-Command -ComputerName $computer -ScriptBlock $script -ErrorAction SilentlyContinue -ErrorVariable err #-Credential $myCred
                
                Try
                {
                if ($Computer -eq "localhost")
                {Set-ExecutionPolicy -ExecutionPolicy $execPolicy -Force}
                
                else
                { $execPolicyResult = Invoke-Command -ComputerName $computer -ScriptBlock {Set-ExecutionPolicy $execPolicy -Force} -ErrorAction SilentlyContinue -ErrorVariable Err}
                }
                catch
                {
                Write-Log "Unable to change the execution Policy for $computer. Please edit manually. Previous Execution Policy $execPolicy" 2
                Write-Host "Unable to change the execution Policy for $computer. Please edit manually. Previous Execution Policy $execPolicy"
                }

				$results | %{   
					$patchStatus = $_.BTIWindowsSupportPresent
                    $isFirmWareUpdated = (-Not($_.BTIDisabledByNoHardwareSupport) -And $_.BTIHardwarePresent)
					<#$isRegistryEnabled = (-Not($_.BTIDisabledBySystemPolicy) -And $_.KVAShadowWindowsSupportEnabled)		

					if ($_.KVAShadowRequired -eq $False) {
						$complaintStatus = $True
                        $comments =  "HW not vulnerable for Meltdown. CVE-2017-5754"
					}

					else {                
						$complaintStatus = $patchStatus  -And $isRegistryEnabled -And $isFirmWareUpdated
					}

				   }#>
                    
                    if (($_.BTIHardwarePresent -eq $true) -and 
                        ($_.BTIWindowsSupportPresent -eq $true) -and
                        ($_.BTIWindowsSupportEnabled -eq $true)) {
                        $SPECTREmitigated = $true                        
                        }
                        else {
                        $SPECTREmitigated = $false
                        }
                    if ($_.btiHardwarePresent -eq $false) {
                        $comments += "Install BIOS/firmware update provided by your device OEM that enables hardware support for the branch target injection mitigation."
                    }
                    if ($_.btiWindowsSupportPresent -eq $false -or $_.kvaShadowPresent -eq $false) {
                        $comments += "Install the latest available updates for Windows with support for speculation control mitigations."
                    }

                    if ($_.KVAShadowRequired -eq $false) {
                        $MeltDownmitigated = $true
                        
                        }
                    elseif (($_.KVAShadowWindowsSupportPresent -eq $true) -and 
                            ($_.KVAShadowWindowsSupportEnabled -eq $true)) {
                        $MeltDownmitigated = $true
                        }
                    else {
                        $MeltDownmitigated = $false
                    }

                 } #Result Variable Manipulation Section
                 } #Else Section
                $serverData = New-Object psobject
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Computer" -Value $serverNickName 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Availability" -Value $Status 
                Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Is HyperV" -Value $isHyperV 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "OS" -Value $OSRunning 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "CPUType" -Value $systemType 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Uptime" -Value $uptime 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "DynamicPatchValidation" -Value ($kb.count -eq 1)
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Availability_Jan2018Patch_Spectre" -Value $patchStatus
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Firmware Update Complete" -Value $isFirmwareUpdated 
                Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Spectre_Mitigated " -Value $SPECTREmitigated
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "MeltDown_Mitigated " -Value $MeltDownmitigated
                Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Comments" -Value $comments
                $serverNickName=" "
                $Status=" "
                $isHyperV=" "
                $OSRunning=" "
                $systemType=" "
                $uptime=" "
                $kb=" "
                $patchStatus=" "
                $isFirmwareUpdated=" "
                $SPECTREmitigated=" "
                $MeltDownmitigated=" "
                $comments=" "

				}
                catch
                {
                $serverData = New-Object psobject
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Computer" -Value $serverNickName 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Availability" -Value $_.Exception.Message
                Remove-Variable $serverNickName
                }   
				$formattedResults += $serverData               
			
				}
			  else
                {
                
                $Status = GetStatusCode( $pingStatus.StatusCode ) 
                $serverData = New-Object psobject
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Computer" -Value $serverNickName 
				Add-Member -InputObject $serverData -MemberType NoteProperty -Name "Availability" -Value $Status
                $formattedResults += $serverData
                Remove-Variable $serverData
                $Err.Clear()
                }
                $comments = ""
				$serverCount += 1

               }
			
		$formattedResults | Export-Csv -Path $DirectoryToSaveTo\Meltdown.csv 
        $attPath = "$DirectoryToSaveTo\meltdown.csv"
        if ($smtpServer -eq "NA")
        {
        Write-Log "No SMTP Server found. Please check the output in the execution directory $curdir" 0
        Write-Host "No SMTP Server found. Please check the output in the execution directory $curdir"
        }
        else
        {
        $result = Mailer($emailTo)
        #Write-Host "Mail Sent"
        Write-Host "Completed Script Execution - More details please check the log - $logfile"
        }

    }
		
			
Catch {
    Write-Host "Error Occured"
    Write-Log $_.Exception.Message 2
    UnLoadModules
    Write-Host "Completed Script with Errors - More details please check the log - $logfile"
    Write-Log "Completed Script with Errors - More details please check the log - $logfile" 2
    Write-Log "-------------------------" 0
    Break
}

If ($?) {
    UnLoadModules
    Write-Log "Completed Script Execution - More details please check the log - $logfile" 0
    Write-Log "-------------------------" 0
    Write-Log " "
    If($OutputOnly){
        $OutObj
    }
}